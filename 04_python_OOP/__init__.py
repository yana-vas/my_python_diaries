# има ли множествено наследяване в пайтън - да
# наследяват се и методите и атрибутите
# може да имаме клас А, който да е наследен от клас Б и клас В, който е наследен от клас Б
# super() реферира към първия наследен клас
# mro - method resolution orde
# ако класа Ц има метод "а" и класа Б е бил наследен от Ц и той също има метод "а", при следния код, кой метод е извикан ц = Ц() ц.а - метода на Ц
# ако в класа Ц НЯМА метод "а" и класа Б е бил наследен от Ц, а той има метод "а", при следния код, кой метод е извикан ц = Ц() ц.а - метода на Б
# ако имаме клас А, който е наследен от Б и клас Б наследен от В, при следния клд в=В() в.а() последното ниво на търсене ще е в: класа object
# Енкапсулацията се ползва за "скриване" и за валидация
# Protected in python -> _name
# По дефиниция в ООП, протектед трябва да бъде видим само от наследниците
# В python protected е видим навсякъде
# Ако имаме private атрибут в пайтън, ъой може ли да бъде достъпен извън класа - да
# по дефиниция в ООП, трябва ли да достъпваме/променяме private атрибути извън класа
# само атрибутите ли може да са private - НЕ
# клас атрибутите могат да се private - ДА
# ако имаме клас А, с instance атрибут name и следния код: а = А() del a.name -> трием го само от инстанцията
# ако клас Б е наследил А и клас А е имал валидация за атрибутите, то клас Б наследява ли валидацията в най-общия случай? - ДА